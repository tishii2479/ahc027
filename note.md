# 考察メモ

- 解が出る方針ではなく、良い解が出る方針を探す

# 12/2

## 観察

- なるべく等間隔に訪れるのが一番良い

- 間隔の配分
    ```
    minimize a1 * (T / d1) ^ 2 + a2 * (T / d2) ^ 2
    r = pow(d1 / d2, 1 / 3) / (1 + pow(d1 / d2, 1 / 3)) : 1 - r となるrが最善
    ```
- 3変数の場合
    ```
    r1 = (r1 + r3) * np.power(a1 / a3, 1/3) / (1 + np.power(a1 / a3, 1/3))
    r2 = (r2 + r3) * np.power(a2 / a3, 1/3) / (1 + np.power(a2 / a3, 1/3))
    r3 = r3

    r1 * (1 + np.power(a1 / a3, 1/3)) = (r1 + r3) * np.power(a1 / a3, 1/3)
    r1 * (1 + np.power(a1 / a3, 1/3) - np.power(a1 / a3, 1/3)) = r3 * np.power(a1 / a3, 1/3)

    r1 = r3 * np.power(a1 / a3, 1/3)
    r2 = r3 * np.power(a2 / a3, 1/3)
    r3 = r3

    r1 + r2 + r3 = 1
    r3 * (\sum_i (a_i / a_3) ^ 1/3) = 1
    r3 = 1 / (\sum_i (a_i / a_3) ^ 1/3)
    ```
- n変数の場合
    ```
    minimize \sum_i a_i / r_i ^ 2
    r_n = 1 / (\sum_i (a_i / a_n) ^ 1/3)
    r_i = r_n * (a_i / a_n) ^ 1/3
    ```
- なるべく回数がrの比率に近い経路を求めることが最善になる
```
r  = 0.2, 0.1, 0.05 * 14
t = 1/0.2, 1/0.1, 1/0.05
t = 5, 10, 20
L = 100 = 20 + 10 + 5 * 14
```

## 方針案

- 初期解がんばる
- 焼きなましで頑張る
- 良い評価関数のビームサーチで頑張る

## メモ

- 各マスを訪れる時刻を保存する？
- 割と高速に差分計算はできそう
    - なら一旦焼いてみるのもありそう
    - 局所解から抜けづらそうなので、
        - 根本的に違う解法（マップを作る、など）
        - 初期解が重要な場合
    - を常に意識する
- 完全情報なので、ちゃんと局所探索できるならビームサーチより焼きなましの方が強そう
    - パスに後から挿入することはできる
- 良い評価関数を組めば貪欲でもある程度戦えそう
- 遅れる時のペナルティはどうやって計算する？
- スタート、繋げる時が難しい気がする
    - 最初はとりあえず最寄りの大きい山に行けば良さそう
- 長さを固定することで見通し良くならないか？
- スコア計算読む

## 貪欲

- 間隔が空いているところを掃除しに行きたい
- 現在の間隔をt、理想的な間隔をt'、距離をdとして、a^(t+d-t')が大きいところを掃除しに行く
    - タイブレークも同じ指標を使用
- 探索は毎回距離を計算するの、大変だね

## 課題

- 近いところをちゃんと回収してくれない
- 動きにめっちゃ無駄が多い
- なんとなくの範囲を決めるのと、その範囲内でどこを掃除するかを区別した評価関数が必要
- もう少し貪欲を粘った方が良い気がする
- 最終的には山を往復する動きになりそう

## 焼きなまし

```
ans = [(0, 0), (0, 1), (0, 2), (1, 2), ..., (0, 0)]
r[0][0] = 0 100 201 300
r[0][1] = 1 101 200 301
r[1][1] = 2 102 202 302
```

- 評価関数は生スコアが使えそう
- 理想間隔は近傍の選択に使えそう
- 解を分割して持つ
- 荒く捉える必要がありそう
- 周りにある赤いやつは綺麗にしてほしい

# 12/2

- 大きいところからスタートして良い
    - 後で(0,0)を通るところからスタートすれば良い
- 経路選択は貪欲でやる必要がありそう
    - 全部焼くのは無理そう
- 訪れたいマスの集合を効率的に訪れる
- 一番大きいところを起点とする？
    - 一番大きいところは周期1/rで訪れる必要がある
- 離れることで増えるマイナスを計算する
- 多分1個ずつ動かすのが勿体無い
- 代表点でTSPをやって、経路を後で決める

- 代表点だけで、周回経路を決める
- 1手ごとに決める必要はない

- 簡略した問題にした方が良さそう
- N = 50くらいの周回経路を考える
- 周回するパスを考える

```
a * t * (d' + t) * d' - t * (d + t) * d
a * t * (d'^2 - d^2 + td' - td)
a * t * (d' - d) * (t + d' + d)
```

- サイクルを作って順序を最適化

- 解空間を狭くする工夫が必要
- 大方針が出てこない、、

## 方針2

- 一番高い山を始点とし、DFSで固定長のサイクルを作る
    - 総移動回数が1e5になる数だけサイクルを作る
- サイクルを山登りで改善する
    - 最初はシャッフルで様子を見る

### 前計算

- 各マス間の距離
    - O(N^4)
        - BFS * N^2
    - `dist[s][t]` := sからtまでの距離
- 各マスの理想間隔`r`を求める
- 各マスの理想回数`t`をカウントする
    - ISSUE: 回数で良いのか？

### DFS

- 始点`S = argmax_s = r[s]`を決める
- サイクルの長さを決定する（`L = 1 / r[i][j]`）
- 一番多い回数のうち、一番近いマスに向かって進むことを繰り返す
    - `count[k]` := 必要な回数がkのマス
- `L / 2 - l <= dist[i][j]`になったら、`S`に戻る
    - dpで、一番良いところを通るものを採用する

#### 計算量

- L: サイクル長 = 200
- K: 近いマスの候補 = 100
- 近いマスに向かって進む: O(K)
- O(L * K + N ^ 2)

### 山登り

- 再構築するサイクルを1個選ぶ
- 再構築する
    - 同じサイクル長となるようにサイクルをDFSで構築する
    - 反転
- スコアを差分計算する
- 改善するならマスの履歴とサイクルを更新する

- 荒く管理する or 場所で管理する
